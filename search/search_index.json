{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home ProfileService is a stand-alone ModuleScript that specialises in loading and auto-saving DataStore profiles. A DataStore Profile (Later referred to as just Profile ) is a set of data which is meant to be loaded up only once inside a Roblox server and then written to and read from locally on that server (With no delays associated with talking with the DataStore every time data changes) whilst being periodically auto-saved and saved immediately once after the server finishes working with the Profile . The benefits of using ProfileService for your game's profiles are: Easy to learn, and eventually forget - ProfileService does not give you any data getter or setter functions. It gives you the freedom to write your own data interface. Built for massive scalability - low resource footprint, no excessive type checking. Great for 100+ player servers. ProfileService automatically spreads the DataStore API calls evenly within the auto-save loop timeframe. Already does the things you wouldn't dare script yourself (but should) - session-locking is essential to keeping your data protected from multiple server editing - this is a potential cause of item loss or item duplication loopholes. ProfileService offers a very comprehensive and short API for handling session-locking yourself or just letting ProfileService do it automatically for you. Future-proof - with features like MetaTags and GlobalUpdates , you will always be able to add new functionality to your profiles without headaches. Made for ambitious projects - ProfileService is a profile object abstraction detached from the Player instance - this allows the developer to create profiles for entities other than players, such as: group-owned houses, savable multiplayer game instances, etc. If anything is missing or broken, file an issue on GitHub . If you need help integrating ProfileService into your project, join the discussion . Disclaimer : Although ProfileService has been thoroughly tested (Auto testing source included - ProfileTest.lua ), it has not been used within a large scale Roblox project yet. ProfileService is the successor to an earlier DataStore implementation used in The Mad Murderer 2 Why not DataStore2? DataStore2 is mostly a Roblox DataStore wrapper module which automatically saves duplicates of your data. ProfileService is an extension module which gives you powerful tools to manage profile session-locking, cross server gifting and profile data organizing. ProfileService protects your data only from the relevant Roblox server problems. It's completely stacked when it comes to protecting your game data from item duplication exploits . ProfileService is striving to be a DataStore solution that is the most accurate implementation of data storage following the development guidelines and practices provided in the official Roblox API .","title":"Home"},{"location":"#home","text":"ProfileService is a stand-alone ModuleScript that specialises in loading and auto-saving DataStore profiles. A DataStore Profile (Later referred to as just Profile ) is a set of data which is meant to be loaded up only once inside a Roblox server and then written to and read from locally on that server (With no delays associated with talking with the DataStore every time data changes) whilst being periodically auto-saved and saved immediately once after the server finishes working with the Profile . The benefits of using ProfileService for your game's profiles are: Easy to learn, and eventually forget - ProfileService does not give you any data getter or setter functions. It gives you the freedom to write your own data interface. Built for massive scalability - low resource footprint, no excessive type checking. Great for 100+ player servers. ProfileService automatically spreads the DataStore API calls evenly within the auto-save loop timeframe. Already does the things you wouldn't dare script yourself (but should) - session-locking is essential to keeping your data protected from multiple server editing - this is a potential cause of item loss or item duplication loopholes. ProfileService offers a very comprehensive and short API for handling session-locking yourself or just letting ProfileService do it automatically for you. Future-proof - with features like MetaTags and GlobalUpdates , you will always be able to add new functionality to your profiles without headaches. Made for ambitious projects - ProfileService is a profile object abstraction detached from the Player instance - this allows the developer to create profiles for entities other than players, such as: group-owned houses, savable multiplayer game instances, etc. If anything is missing or broken, file an issue on GitHub . If you need help integrating ProfileService into your project, join the discussion . Disclaimer : Although ProfileService has been thoroughly tested (Auto testing source included - ProfileTest.lua ), it has not been used within a large scale Roblox project yet. ProfileService is the successor to an earlier DataStore implementation used in The Mad Murderer 2","title":"Home"},{"location":"#why-not-datastore2","text":"DataStore2 is mostly a Roblox DataStore wrapper module which automatically saves duplicates of your data. ProfileService is an extension module which gives you powerful tools to manage profile session-locking, cross server gifting and profile data organizing. ProfileService protects your data only from the relevant Roblox server problems. It's completely stacked when it comes to protecting your game data from item duplication exploits . ProfileService is striving to be a DataStore solution that is the most accurate implementation of data storage following the development guidelines and practices provided in the official Roblox API .","title":"Why not DataStore2?"},{"location":"api/","text":"Warning Never yield (use wait() or asynchronous Roblox API calls) inside listener functions Notice Methods with Async in their name are methods that will yield - just like wait() ProfileService ProfileService.ServiceLocked ProfileService . ServiceLocked [ bool ] Set to false when the Roblox server is shutting down. ProfileStore methods should not be called after this value is set to false ProfileService.IssueSignal ProfileService . IssueSignal [ ScriptSignal ]( error_message [ string ]) Analytics endpoint for DataStore error logging. Example usage: ProfileService . IssueSignal : Connect ( function ( error_message ) pcall ( function () AnalyticsService : FireEvent ( \"ProfileServiceIssue\" , error_message ) end ) end ) ProfileService.CorruptionSignal ProfileService . CorruptionSignal [ ScriptSignal ]( profile_store_name [ string ], profile_key [ string ]) Analytics endpoint for cases when a DataStore key returns a value that has all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a non table value ProfileService.CriticalStateSignal ProfileService . CriticalStateSignal [ ScriptSignal ] ( is_critical_state [ bool ]) Analytics endpoint for cases when DataStore is throwing too many errors and it's most likely affecting your game really really bad - this could be due to developer errors or due to Roblox server problems. Could be used to alert players about data store outages. ProfileService.GetProfileStore() ProfileService . GetProfileStore ( profile_store_name , profile_template ) --> [ProfileStore] -- profile_store_name [string] -- DataStore name -- profile_template [table] -- Profile.Data will default to -- given table (deep-copy) when no data was saved previously ProfileStore objects expose methods for loading / viewing profiles and sending global updates. Equivalent of :GetDataStore() in Roblox DataStoreService API. Notice profile_template is only copied for Profile.Data for new profiles. Changes made to profile_template will not fill in missing components in profiles that have been saved before changing profile_template . You may create your own function to fill in the missing components in Profile.Data as soon as it is loaded or have nil exceptions in your personal :Get() and :Set() method libraries. ProfileStore ProfileStore:LoadProfileAsync() ProfileStore : LoadProfileAsync ( profile_key , not_released_handler ) --> [Profile] or nil -- profile_key [string] -- DataStore key -- not_released_handler: -- \"ForceLoad\" -- or -- \"Steal\" -- or -- [function](place_id, game_job_id) For basic usage, pass \"ForceLoad\" for the not_released_handler argument. not_released_handler as a function argument is called when the profile is session-locked by a remote Roblox server: local profile = ProfileStore : LoadProfileAsync ( \"Player_2312310\" , function ( place_id , game_job_id ) -- place_id and game_job_id identify the Roblox server that has -- this profile currently locked. In rare cases, if the server -- crashes, the profile will stay locked until ForceLoaded by -- a new session. return \"Repeat\" or \"Cancel\" or \"ForceLoad\" or \"Steal\" end ) not_released_handler must return one of the three values: return \"Repeat\" - ProfileService will repeat the profile loading proccess and may call the release handler again return \"Cancel\" - :LoadProfileAsync() will immediately return nil return \"ForceLoad\" - ProfileService will indefinetly attempt to load the profile. If the profile is session-locked by a remote Roblox server, it will either be released for that remote server or \"stolen\" (Stealing is nescessary for remote servers that are not responding in time and for handling crashed server session-locks). return \"Steal\" - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying a session lock for this session. \"Steal\" can be used to clear dead session locks faster than \"ForceLoad\" assuming your code knows that the session lock is dead. Notice ProfileService saves profiles to live DataStore keys in Roblox Studio when Roblox API services are enabled . See ProfileStore.Mock if saving to live keys during testing is not desired. Warning :LoadProfileAsync() can return nil when another remote Roblox server attempts to load the profile at the same time. This case should be extremely rare and it would be recommended to :Kick() the player if :LoadProfileAsync() does not return a Profile object. Do not load a profile of the same key again before it is released Trying to load a profile that has already been session-locked on the same server will result in an error. You may, however, instantly load the profile again after releasing it with Profile:Release() . ProfileStore:GlobalUpdateProfileAsync() ProfileStore : GlobalUpdateProfileAsync ( profile_key , update_handler ) --> [GlobalUpdates] or nil -- profile_key [string] -- DataStore key -- update_handler [function](global_updates) -- This function is -- called with a GlobalUpdates object Used to create and manage Active global updates for a specified Profile . Can be called on any Roblox server of your game. Updates should reach the recipient in less than 30 seconds, regardless of whether it was called on the same server the Profile is session-locked to. See Global Updates for more information. Example usage of :GlobalUpdateProfileAsync() : ProfileStore : GlobalUpdateProfileAsync ( \"Player_2312310\" , function ( global_updates ) global_updates : AddActiveUpdate ({ Type = \"AdminGift\" , Item = \"Coins\" , Amount = 1000 , }) end ) Notice :GlobalUpdateProfileAsync() will work for profiles that haven't been created (profiles are created when they're loaded using :LoadProfileAsync() for the first time) Yielding inside the update_handler function will throw an error ProfileStore:ViewProfileAsync() ProfileStore : ViewProfileAsync ( profile_key ) --> [Profile] or nil -- profile_key [string] -- DataStore key Writing and saving is not possible for profiles in view mode. Profile.Data and Profile.MetaData will be nil if the profile hasn't been created. ProfileStore:WipeProfileAsync() ProfileStore : WipeProfileAsync ( profile_key ) --> is_wipe_successful [bool] -- profile_key [string] -- DataStore key Use :WipeProfileAsync() to erase user data when complying with right of erasure requests. In live Roblox servers :WipeProfileAsync() must be used on profiles created through ProfileStore.Mock after Profile:Release() and it's known that the Profile will no longer be loaded again. ProfileStore.Mock local ProfileTemplate = {} local GameProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , ProfileTemplate ) local LiveProfile = GameProfileStore : LoadProfileAsync ( \"profile_key\" , \"ForceLoad\" ) local MockProfile = GameProfileStore . Mock : LoadProfileAsync ( \"profile_key\" , \"ForceLoad\" ) print ( LiveProfile ~= MockProfile ) --> true -- When done using mock profile on live servers: (Prevent memory leak) MockProfile : Release () GameProfileStore . Mock : WipeProfile ( \"profile_key\" ) -- You don't really have to wipe mock profiles in studio testing ProfileStore.Mock is a reflection of methods available in the ProfileStore object with the exception of profile operations being performed on profiles stored on a separate, detached \"fake\" DataStore that will be forgotten when the game session ends. You may load profiles of the same key from ProfileStore and ProfileStore.Mock in parallel - these will be two different profiles because the regular and mock versions of the same ProfileStore are completely isolated from each other. ProfileStore.Mock is useful for customizing your testing environment in cases when you want to enable Roblox API services in studio, but don't want ProfileService to save to live keys: local RunService = game : GetService ( \"RunService\" ) local GameProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , ProfileTemplate ) if RunService : IsStudio () == true then GameProfileStore = GameProfileStore . Mock end A few more things: Even when Roblox API services are disabled, ProfileStore and ProfileStore.Mock will store profiles in separate stores. It's better to think of ProfileStore and ProfileStore.Mock as two different ProfileStore objects unrelated to each other in any way. It's possible to create a project that utilizes both live and mock profiles on live servers! Profile Profile.Data Profile . Data [ table ] Profile.Data is the primary variable of a Profile object. The developer is free to read and write from the table while it is automatically saved to the DataStore . Profile.Data will no longer be saved after being released remotely or locally via Profile:Release() . Profile.MetaData Profile . MetaData [ table ] ( Read - only ) -- Data about the profile itself Profile . MetaData . ProfileCreateTime [ number ] ( Read - only ) -- os.time() timestamp of profile creation Profile . MetaData . SessionLoadCount [ number ] ( Read - only ) -- Amount of times the profile was loaded Profile . MetaData . ActiveSession [ table ] or nil ( Read - only ) -- {place_id, game_job_id} or nil -- Set to a session link if a Roblox server is currently the -- owner of this profile; nil if released Profile . MetaData . MetaTags [ table ] ( Writable ) -- {[\"tag_name\"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data Profile . MetaData . MetaTagsLatest [ table ] ( Read - only ) -- the most recent version of MetaData.MetaTags which has -- been saved to the DataStore during the last auto-save -- or Profile:Save() call Profile.MetaData is a table containing data about the profile itself. Profile.MetaData.MetaTags is saved on the same DataStore key together with Profile.Data . Profile.GlobalUpdates Profile . GlobalUpdates [ GlobalUpdates ] This is the GlobalUpdates object tied to this specific Profile . It exposes GlobalUpdates methods for update processing. (See Global Updates for more info) Profile:IsActive() Profile : IsActive () --> [bool] Returns true while the profile is session-locked and saving of changes to Profile.Data is guaranteed. Profile:GetMetaTag() Profile : GetMetaTag ( tag_name ) --> value -- tag_name [string] Equivalent of Profile.MetaData.MetaTags[tag_name] . See Profile:SetMetaTag() for more info. Profile:ListenToRelease() Profile : ListenToRelease ( listener ) --> [ScriptConnection] (place_id / nil, game_job_id / nil) -- listener [function](place_id / nil, game_job_id / nil) Listener functions subscribed to Profile:ListenToRelease() will be called when the profile is released remotely (Being \"ForceLoad\" 'ed on a remote server) or locally ( Profile:Release() ). In common practice, the profile will rarely be released before the player leaves the game so it's recommended to simply :Kick() the Player when this happens. Warning After Profile:ListenToRelease() is triggered, it is too late to change Profile.Data for the final time. As long as the profile is active ( Profile:IsActive() == true ), you should store all profile related data immediately after it becomes available. An item trading operation between two profiles must happen without any yielding after it is confirmed that both profiles are active. Profile:Release() Profile : Release () Removes the session lock for this profile for this Roblox server. Call this method after you're done working with the Profile object. Profile data will be immediately saved for the last time. Profile:SetMetaTag() Profile : SetMetaTag ( tag_name , value ) -- tag_name [string] -- value -- Any value supported by DataStore Equivalent of Profile.MetaData.MetaTags[tag_name] = value . Use for tagging your profile with information about itself such as: profile:SetMetaTag(\"DataVersion\", 1) to let your game code know whether Profile.Data needs to be converted after massive changes to the game. Anything set through profile:SetMetaTag(tag_name, value) will be available through Profile.MetaData.MetaTagsLatest[tag_name] after an auto-save or a :Save() call - Profile.MetaData.MetaTagsLatest is a version of Profile.MetaData.MetaTags that has been successfully saved to the DataStore. Warning Calling Profile:SetMetaTag() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method. Notice You can use Profile.MetaData.MetaTagsLatest for product purchase confirmation (By storing receiptInfo.PurchaseId values inside Profile.MetaData.MetaTags and waiting for them to appear in Profile.MetaData.MetaTagsLatest ). Don't forget to clear really old PurchaseId 's to stay under DataStore limits. Profile:Save() Profile : Save () -- Call to quickly progress GlobalUpdates -- state or to speed up save validation processes -- (Does not yield) Call Profile:Save() to quickly progress GlobalUpdates state or to speed up the propagation of Profile.MetaData.MetaTags changes to Profile.MetaData.MetaTagsLatest . Profile:Save() should not be called for saving Profile.Data or Profile.MetaData.MetaTags - this is already done for you automatically. Warning Calling Profile:Save() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method. Global Updates Global updates is a powerful feature of ProfileService, used for sending information to a desired player profile across servers, within the server or to a player profile that is not currently active in any Roblox server (Kind of like MessagingService , but slower and doesn't require the recipient to be active). The primary intended use of global updates is to support sending gifts among players, or giving items to players through a custom admin tool. The benefit of using global updates is it's API simplicity (This is as simple as it gets, sorry \ud83d\ude02) and the fact that global updates are pulled from the DataStore whenever the profile is auto-saved at no additional expense of more DataStore calls! Global updates can be Active , Locked and Cleared : Whenever a global update is created, it will be Active by default Active updates can be changed or cleared within a :GlobalUpdateProfileAsync() call Normally, when the profile is active on a Roblox server, you should always progress all Active updates to the Locked state Locked updates can no longer be changed or cleared within a :GlobalUpdateProfileAsync() call Locked updates are ready to be processed (e.g., add gift to player inventory) and imediately Locked by calling :LockActiveUpdate(update_id) Cleared updates will immediately disappear from the profile forever Always available GlobalUpdates:GetActiveUpdates() GlobalUpdates : GetActiveUpdates () --> [table] { {update_id, update_data}, ...} Should be used immediately after a Profile is loaded to scan and progress any pending Active updates to Locked state: for _ , update in ipairs ( profile . GlobalUpdates : GetActiveUpdates ()) do profile . GlobalUpdates : LockActiveUpdate ( update [ 1 ]) end GlobalUpdates:GetLockedUpdates() GlobalUpdates : GetLockedUpdates () --> [table] { {update_id, update_data}, ...} Should be used immediately after a Profile is loaded to scan and progress any pending Locked updates to Cleared state: for _ , update in ipairs ( profile . GlobalUpdates : GetLockedUpdates ()) do local update_id = update [ 1 ] local update_data = update [ 2 ] if update_data . Type == \"AdminGift\" and update_data . Item == \"Coins\" then profile . Data . Coins = profile . Data . Coins + update_data . Amount end profile . GlobalUpdates : ClearLockedUpdate ( update_id ) end Only when accessed from Profile.GlobalUpdates GlobalUpdates:ListenToNewActiveUpdate() GlobalUpdates : ListenToNewActiveUpdate ( listener ) --> [ScriptConnection] -- listener [function](update_id, update_data) In most games, you should progress all Active updates to Locked state: profile . GlobalUpdates : ListenToNewActiveUpdate ( function ( update_id , update_data ) profile . GlobalUpdates : LockActiveUpdate ( update_id ) end ) GlobalUpdates:ListenToNewLockedUpdate() GlobalUpdates : ListenToNewLockedUpdate ( listener ) --> [ScriptConnection] -- listener [function](update_id, update_data) -- Must always call GlobalUpdates:ClearLockedUpdate(update_id) -- after processing the locked update. When you get a Locked update via GlobalUpdates:ListenToNewLockedUpdate() , the update is ready to be proccessed and immediately locked: profile . GlobalUpdates : ListenToNewLockedUpdate ( function ( update_id , update_data ) if update_data . Type == \"AdminGift\" and update_data . Item == \"Coins\" then profile . Data . Coins = profile . Data . Coins + update_data . Amount end profile . GlobalUpdates : ClearLockedUpdate ( update_id ) end ) GlobalUpdates:LockActiveUpdate() GlobalUpdates : LockActiveUpdate ( update_id ) -- update_id [number] -- Id of an existing global update Turns an Active update into a Locked update. Will invoke GlobalUpdates:ListenToNewLockedUpdate() after an auto-save (less than 30 seconds) or Profile:Save() . Warning Calling GlobalUpdates:LockActiveUpdate() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method. ProfileService guarantees that the Profile will be active when GlobalUpdates:ListenToNewActiveUpdate() listeners are triggered. GlobalUpdates:ClearLockedUpdate() GlobalUpdates : ClearLockedUpdate ( update_id ) -- update_id [number] -- Id of an existing global update Clears a Locked update completely from the profile. Warning Calling GlobalUpdates:ClearLockedUpdate() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method. ProfileService guarantees that the Profile will be active when GlobalUpdates:ListenToNewLockedUpdate() listeners are triggered. Available inside update_handler during a ProfileStore:GlobalUpdateProfileAsync() call GlobalUpdates:AddActiveUpdate() GlobalUpdates : AddActiveUpdate ( update_data ) -- update_data [table] -- Your custom global update data Used to send a new Active update to the profile. GlobalUpdates:ChangeActiveUpdate() GlobalUpdates : ChangeActiveUpdate ( update_id , update_data ) -- update_id [number] -- Id of an existing global update -- update_data [table] -- New data that replaces previously set update_data Changing Active updates can be used for stacking player gifts, particularly when lots of players can be sending lots of gifts to a Youtube celebrity so the Profile would not exceed the DataStore data limit . GlobalUpdates:ClearActiveUpdate() GlobalUpdates : ClearActiveUpdate ( update_id ) -- update_id [number] -- Id of an existing global update Removes an Active update from the profile completely.","title":"API"},{"location":"api/#profileservice","text":"","title":"ProfileService"},{"location":"api/#profileserviceservicelocked","text":"ProfileService . ServiceLocked [ bool ] Set to false when the Roblox server is shutting down. ProfileStore methods should not be called after this value is set to false","title":"ProfileService.ServiceLocked"},{"location":"api/#profileserviceissuesignal","text":"ProfileService . IssueSignal [ ScriptSignal ]( error_message [ string ]) Analytics endpoint for DataStore error logging. Example usage: ProfileService . IssueSignal : Connect ( function ( error_message ) pcall ( function () AnalyticsService : FireEvent ( \"ProfileServiceIssue\" , error_message ) end ) end )","title":"ProfileService.IssueSignal"},{"location":"api/#profileservicecorruptionsignal","text":"ProfileService . CorruptionSignal [ ScriptSignal ]( profile_store_name [ string ], profile_key [ string ]) Analytics endpoint for cases when a DataStore key returns a value that has all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a non table value","title":"ProfileService.CorruptionSignal"},{"location":"api/#profileservicecriticalstatesignal","text":"ProfileService . CriticalStateSignal [ ScriptSignal ] ( is_critical_state [ bool ]) Analytics endpoint for cases when DataStore is throwing too many errors and it's most likely affecting your game really really bad - this could be due to developer errors or due to Roblox server problems. Could be used to alert players about data store outages.","title":"ProfileService.CriticalStateSignal"},{"location":"api/#profileservicegetprofilestore","text":"ProfileService . GetProfileStore ( profile_store_name , profile_template ) --> [ProfileStore] -- profile_store_name [string] -- DataStore name -- profile_template [table] -- Profile.Data will default to -- given table (deep-copy) when no data was saved previously ProfileStore objects expose methods for loading / viewing profiles and sending global updates. Equivalent of :GetDataStore() in Roblox DataStoreService API. Notice profile_template is only copied for Profile.Data for new profiles. Changes made to profile_template will not fill in missing components in profiles that have been saved before changing profile_template . You may create your own function to fill in the missing components in Profile.Data as soon as it is loaded or have nil exceptions in your personal :Get() and :Set() method libraries.","title":"ProfileService.GetProfileStore()"},{"location":"api/#profilestore","text":"","title":"ProfileStore"},{"location":"api/#profilestoreloadprofileasync","text":"ProfileStore : LoadProfileAsync ( profile_key , not_released_handler ) --> [Profile] or nil -- profile_key [string] -- DataStore key -- not_released_handler: -- \"ForceLoad\" -- or -- \"Steal\" -- or -- [function](place_id, game_job_id) For basic usage, pass \"ForceLoad\" for the not_released_handler argument. not_released_handler as a function argument is called when the profile is session-locked by a remote Roblox server: local profile = ProfileStore : LoadProfileAsync ( \"Player_2312310\" , function ( place_id , game_job_id ) -- place_id and game_job_id identify the Roblox server that has -- this profile currently locked. In rare cases, if the server -- crashes, the profile will stay locked until ForceLoaded by -- a new session. return \"Repeat\" or \"Cancel\" or \"ForceLoad\" or \"Steal\" end ) not_released_handler must return one of the three values: return \"Repeat\" - ProfileService will repeat the profile loading proccess and may call the release handler again return \"Cancel\" - :LoadProfileAsync() will immediately return nil return \"ForceLoad\" - ProfileService will indefinetly attempt to load the profile. If the profile is session-locked by a remote Roblox server, it will either be released for that remote server or \"stolen\" (Stealing is nescessary for remote servers that are not responding in time and for handling crashed server session-locks). return \"Steal\" - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying a session lock for this session. \"Steal\" can be used to clear dead session locks faster than \"ForceLoad\" assuming your code knows that the session lock is dead. Notice ProfileService saves profiles to live DataStore keys in Roblox Studio when Roblox API services are enabled . See ProfileStore.Mock if saving to live keys during testing is not desired. Warning :LoadProfileAsync() can return nil when another remote Roblox server attempts to load the profile at the same time. This case should be extremely rare and it would be recommended to :Kick() the player if :LoadProfileAsync() does not return a Profile object. Do not load a profile of the same key again before it is released Trying to load a profile that has already been session-locked on the same server will result in an error. You may, however, instantly load the profile again after releasing it with Profile:Release() .","title":"ProfileStore:LoadProfileAsync()"},{"location":"api/#profilestoreglobalupdateprofileasync","text":"ProfileStore : GlobalUpdateProfileAsync ( profile_key , update_handler ) --> [GlobalUpdates] or nil -- profile_key [string] -- DataStore key -- update_handler [function](global_updates) -- This function is -- called with a GlobalUpdates object Used to create and manage Active global updates for a specified Profile . Can be called on any Roblox server of your game. Updates should reach the recipient in less than 30 seconds, regardless of whether it was called on the same server the Profile is session-locked to. See Global Updates for more information. Example usage of :GlobalUpdateProfileAsync() : ProfileStore : GlobalUpdateProfileAsync ( \"Player_2312310\" , function ( global_updates ) global_updates : AddActiveUpdate ({ Type = \"AdminGift\" , Item = \"Coins\" , Amount = 1000 , }) end ) Notice :GlobalUpdateProfileAsync() will work for profiles that haven't been created (profiles are created when they're loaded using :LoadProfileAsync() for the first time) Yielding inside the update_handler function will throw an error","title":"ProfileStore:GlobalUpdateProfileAsync()"},{"location":"api/#profilestoreviewprofileasync","text":"ProfileStore : ViewProfileAsync ( profile_key ) --> [Profile] or nil -- profile_key [string] -- DataStore key Writing and saving is not possible for profiles in view mode. Profile.Data and Profile.MetaData will be nil if the profile hasn't been created.","title":"ProfileStore:ViewProfileAsync()"},{"location":"api/#profilestorewipeprofileasync","text":"ProfileStore : WipeProfileAsync ( profile_key ) --> is_wipe_successful [bool] -- profile_key [string] -- DataStore key Use :WipeProfileAsync() to erase user data when complying with right of erasure requests. In live Roblox servers :WipeProfileAsync() must be used on profiles created through ProfileStore.Mock after Profile:Release() and it's known that the Profile will no longer be loaded again.","title":"ProfileStore:WipeProfileAsync()"},{"location":"api/#profilestoremock","text":"local ProfileTemplate = {} local GameProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , ProfileTemplate ) local LiveProfile = GameProfileStore : LoadProfileAsync ( \"profile_key\" , \"ForceLoad\" ) local MockProfile = GameProfileStore . Mock : LoadProfileAsync ( \"profile_key\" , \"ForceLoad\" ) print ( LiveProfile ~= MockProfile ) --> true -- When done using mock profile on live servers: (Prevent memory leak) MockProfile : Release () GameProfileStore . Mock : WipeProfile ( \"profile_key\" ) -- You don't really have to wipe mock profiles in studio testing ProfileStore.Mock is a reflection of methods available in the ProfileStore object with the exception of profile operations being performed on profiles stored on a separate, detached \"fake\" DataStore that will be forgotten when the game session ends. You may load profiles of the same key from ProfileStore and ProfileStore.Mock in parallel - these will be two different profiles because the regular and mock versions of the same ProfileStore are completely isolated from each other. ProfileStore.Mock is useful for customizing your testing environment in cases when you want to enable Roblox API services in studio, but don't want ProfileService to save to live keys: local RunService = game : GetService ( \"RunService\" ) local GameProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , ProfileTemplate ) if RunService : IsStudio () == true then GameProfileStore = GameProfileStore . Mock end A few more things: Even when Roblox API services are disabled, ProfileStore and ProfileStore.Mock will store profiles in separate stores. It's better to think of ProfileStore and ProfileStore.Mock as two different ProfileStore objects unrelated to each other in any way. It's possible to create a project that utilizes both live and mock profiles on live servers!","title":"ProfileStore.Mock"},{"location":"api/#profile","text":"","title":"Profile"},{"location":"api/#profiledata","text":"Profile . Data [ table ] Profile.Data is the primary variable of a Profile object. The developer is free to read and write from the table while it is automatically saved to the DataStore . Profile.Data will no longer be saved after being released remotely or locally via Profile:Release() .","title":"Profile.Data"},{"location":"api/#profilemetadata","text":"Profile . MetaData [ table ] ( Read - only ) -- Data about the profile itself Profile . MetaData . ProfileCreateTime [ number ] ( Read - only ) -- os.time() timestamp of profile creation Profile . MetaData . SessionLoadCount [ number ] ( Read - only ) -- Amount of times the profile was loaded Profile . MetaData . ActiveSession [ table ] or nil ( Read - only ) -- {place_id, game_job_id} or nil -- Set to a session link if a Roblox server is currently the -- owner of this profile; nil if released Profile . MetaData . MetaTags [ table ] ( Writable ) -- {[\"tag_name\"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data Profile . MetaData . MetaTagsLatest [ table ] ( Read - only ) -- the most recent version of MetaData.MetaTags which has -- been saved to the DataStore during the last auto-save -- or Profile:Save() call Profile.MetaData is a table containing data about the profile itself. Profile.MetaData.MetaTags is saved on the same DataStore key together with Profile.Data .","title":"Profile.MetaData"},{"location":"api/#profileglobalupdates","text":"Profile . GlobalUpdates [ GlobalUpdates ] This is the GlobalUpdates object tied to this specific Profile . It exposes GlobalUpdates methods for update processing. (See Global Updates for more info)","title":"Profile.GlobalUpdates"},{"location":"api/#profileisactive","text":"Profile : IsActive () --> [bool] Returns true while the profile is session-locked and saving of changes to Profile.Data is guaranteed.","title":"Profile:IsActive()"},{"location":"api/#profilegetmetatag","text":"Profile : GetMetaTag ( tag_name ) --> value -- tag_name [string] Equivalent of Profile.MetaData.MetaTags[tag_name] . See Profile:SetMetaTag() for more info.","title":"Profile:GetMetaTag()"},{"location":"api/#profilelistentorelease","text":"Profile : ListenToRelease ( listener ) --> [ScriptConnection] (place_id / nil, game_job_id / nil) -- listener [function](place_id / nil, game_job_id / nil) Listener functions subscribed to Profile:ListenToRelease() will be called when the profile is released remotely (Being \"ForceLoad\" 'ed on a remote server) or locally ( Profile:Release() ). In common practice, the profile will rarely be released before the player leaves the game so it's recommended to simply :Kick() the Player when this happens. Warning After Profile:ListenToRelease() is triggered, it is too late to change Profile.Data for the final time. As long as the profile is active ( Profile:IsActive() == true ), you should store all profile related data immediately after it becomes available. An item trading operation between two profiles must happen without any yielding after it is confirmed that both profiles are active.","title":"Profile:ListenToRelease()"},{"location":"api/#profilerelease","text":"Profile : Release () Removes the session lock for this profile for this Roblox server. Call this method after you're done working with the Profile object. Profile data will be immediately saved for the last time.","title":"Profile:Release()"},{"location":"api/#profilesetmetatag","text":"Profile : SetMetaTag ( tag_name , value ) -- tag_name [string] -- value -- Any value supported by DataStore Equivalent of Profile.MetaData.MetaTags[tag_name] = value . Use for tagging your profile with information about itself such as: profile:SetMetaTag(\"DataVersion\", 1) to let your game code know whether Profile.Data needs to be converted after massive changes to the game. Anything set through profile:SetMetaTag(tag_name, value) will be available through Profile.MetaData.MetaTagsLatest[tag_name] after an auto-save or a :Save() call - Profile.MetaData.MetaTagsLatest is a version of Profile.MetaData.MetaTags that has been successfully saved to the DataStore. Warning Calling Profile:SetMetaTag() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method. Notice You can use Profile.MetaData.MetaTagsLatest for product purchase confirmation (By storing receiptInfo.PurchaseId values inside Profile.MetaData.MetaTags and waiting for them to appear in Profile.MetaData.MetaTagsLatest ). Don't forget to clear really old PurchaseId 's to stay under DataStore limits.","title":"Profile:SetMetaTag()"},{"location":"api/#profilesave","text":"Profile : Save () -- Call to quickly progress GlobalUpdates -- state or to speed up save validation processes -- (Does not yield) Call Profile:Save() to quickly progress GlobalUpdates state or to speed up the propagation of Profile.MetaData.MetaTags changes to Profile.MetaData.MetaTagsLatest . Profile:Save() should not be called for saving Profile.Data or Profile.MetaData.MetaTags - this is already done for you automatically. Warning Calling Profile:Save() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method.","title":"Profile:Save()"},{"location":"api/#global-updates","text":"Global updates is a powerful feature of ProfileService, used for sending information to a desired player profile across servers, within the server or to a player profile that is not currently active in any Roblox server (Kind of like MessagingService , but slower and doesn't require the recipient to be active). The primary intended use of global updates is to support sending gifts among players, or giving items to players through a custom admin tool. The benefit of using global updates is it's API simplicity (This is as simple as it gets, sorry \ud83d\ude02) and the fact that global updates are pulled from the DataStore whenever the profile is auto-saved at no additional expense of more DataStore calls! Global updates can be Active , Locked and Cleared : Whenever a global update is created, it will be Active by default Active updates can be changed or cleared within a :GlobalUpdateProfileAsync() call Normally, when the profile is active on a Roblox server, you should always progress all Active updates to the Locked state Locked updates can no longer be changed or cleared within a :GlobalUpdateProfileAsync() call Locked updates are ready to be processed (e.g., add gift to player inventory) and imediately Locked by calling :LockActiveUpdate(update_id) Cleared updates will immediately disappear from the profile forever","title":"Global Updates"},{"location":"api/#always-available","text":"","title":"Always available"},{"location":"api/#globalupdatesgetactiveupdates","text":"GlobalUpdates : GetActiveUpdates () --> [table] { {update_id, update_data}, ...} Should be used immediately after a Profile is loaded to scan and progress any pending Active updates to Locked state: for _ , update in ipairs ( profile . GlobalUpdates : GetActiveUpdates ()) do profile . GlobalUpdates : LockActiveUpdate ( update [ 1 ]) end","title":"GlobalUpdates:GetActiveUpdates()"},{"location":"api/#globalupdatesgetlockedupdates","text":"GlobalUpdates : GetLockedUpdates () --> [table] { {update_id, update_data}, ...} Should be used immediately after a Profile is loaded to scan and progress any pending Locked updates to Cleared state: for _ , update in ipairs ( profile . GlobalUpdates : GetLockedUpdates ()) do local update_id = update [ 1 ] local update_data = update [ 2 ] if update_data . Type == \"AdminGift\" and update_data . Item == \"Coins\" then profile . Data . Coins = profile . Data . Coins + update_data . Amount end profile . GlobalUpdates : ClearLockedUpdate ( update_id ) end","title":"GlobalUpdates:GetLockedUpdates()"},{"location":"api/#only-when-accessed-from-profileglobalupdates","text":"","title":"Only when accessed from Profile.GlobalUpdates"},{"location":"api/#globalupdateslistentonewactiveupdate","text":"GlobalUpdates : ListenToNewActiveUpdate ( listener ) --> [ScriptConnection] -- listener [function](update_id, update_data) In most games, you should progress all Active updates to Locked state: profile . GlobalUpdates : ListenToNewActiveUpdate ( function ( update_id , update_data ) profile . GlobalUpdates : LockActiveUpdate ( update_id ) end )","title":"GlobalUpdates:ListenToNewActiveUpdate()"},{"location":"api/#globalupdateslistentonewlockedupdate","text":"GlobalUpdates : ListenToNewLockedUpdate ( listener ) --> [ScriptConnection] -- listener [function](update_id, update_data) -- Must always call GlobalUpdates:ClearLockedUpdate(update_id) -- after processing the locked update. When you get a Locked update via GlobalUpdates:ListenToNewLockedUpdate() , the update is ready to be proccessed and immediately locked: profile . GlobalUpdates : ListenToNewLockedUpdate ( function ( update_id , update_data ) if update_data . Type == \"AdminGift\" and update_data . Item == \"Coins\" then profile . Data . Coins = profile . Data . Coins + update_data . Amount end profile . GlobalUpdates : ClearLockedUpdate ( update_id ) end )","title":"GlobalUpdates:ListenToNewLockedUpdate()"},{"location":"api/#globalupdateslockactiveupdate","text":"GlobalUpdates : LockActiveUpdate ( update_id ) -- update_id [number] -- Id of an existing global update Turns an Active update into a Locked update. Will invoke GlobalUpdates:ListenToNewLockedUpdate() after an auto-save (less than 30 seconds) or Profile:Save() . Warning Calling GlobalUpdates:LockActiveUpdate() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method. ProfileService guarantees that the Profile will be active when GlobalUpdates:ListenToNewActiveUpdate() listeners are triggered.","title":"GlobalUpdates:LockActiveUpdate()"},{"location":"api/#globalupdatesclearlockedupdate","text":"GlobalUpdates : ClearLockedUpdate ( update_id ) -- update_id [number] -- Id of an existing global update Clears a Locked update completely from the profile. Warning Calling GlobalUpdates:ClearLockedUpdate() when the Profile is released will throw an error. You can check Profile:IsActive() before using this method. ProfileService guarantees that the Profile will be active when GlobalUpdates:ListenToNewLockedUpdate() listeners are triggered.","title":"GlobalUpdates:ClearLockedUpdate()"},{"location":"api/#available-inside-update_handler-during-a-profilestoreglobalupdateprofileasync-call","text":"","title":"Available inside update_handler during a ProfileStore:GlobalUpdateProfileAsync() call"},{"location":"api/#globalupdatesaddactiveupdate","text":"GlobalUpdates : AddActiveUpdate ( update_data ) -- update_data [table] -- Your custom global update data Used to send a new Active update to the profile.","title":"GlobalUpdates:AddActiveUpdate()"},{"location":"api/#globalupdateschangeactiveupdate","text":"GlobalUpdates : ChangeActiveUpdate ( update_id , update_data ) -- update_id [number] -- Id of an existing global update -- update_data [table] -- New data that replaces previously set update_data Changing Active updates can be used for stacking player gifts, particularly when lots of players can be sending lots of gifts to a Youtube celebrity so the Profile would not exceed the DataStore data limit .","title":"GlobalUpdates:ChangeActiveUpdate()"},{"location":"api/#globalupdatesclearactiveupdate","text":"GlobalUpdates : ClearActiveUpdate ( update_id ) -- update_id [number] -- Id of an existing global update Removes an Active update from the profile completely.","title":"GlobalUpdates:ClearActiveUpdate()"},{"location":"troubleshooting/","text":"Whether you're still writing your game code or already ran into a problem while using ProfileService, this page is a valuable resource for avoiding several crucial mistakes. Problems in Roblox studio testing By default, data saved with ProfileService in Roblox Studio will not persist. This can be changed by enabling studio access to API services . Warning When studio access to API services is enabled, ProfileService will write to live DataStore keys of the game you're editing (unless ProfileStore.Mock is used) and you might accidentally make unwanted changes to your game's saved data. For more info, check the official documentation . Saving data which Roblox cannot serialize I've made the decision to opt-out Profile.Data and Profile.MetaData.MetaTags automatic checking for unserializable data types for efficiency reasons. Consequently, you must be aware of what you MUST AVOID writing inside Profile.Data or Profile.MetaData.MetaTags , directly and inside any nested tables: NaN values - you can check if a number is NaN by comparing it with itself - print(NaN == NaN) --> false (e.g., Profile.Data = {Experience = 0/0} ). NaN values are a result of division by zero and edge cases of some math operations ( math.acos(2) is -NaN ). Table keys that are neither strings nor numbers (e.g., Profile.Data[game.Workspace] = true ). Mixing string keys with number keys within the same table (e.g., Profile.Data = {Coins = 100, [5] = \"yes\"} ). Storing tables with non-sequential indexes (e.g., Profile.Data = {[1] = \"Apple\", [2] = \"Banana\", [3546] = \"Peanut\"} ). If you really have to store non-sequential numbers as indexes, you will have to turn those numbers into string indexes: Profile.Data.Friends[tostring(user_id)] = {GoodFriend = true} . Storing cyclic tables (e.g., Profile.Data = {Self = Profile.Data} ). Storing any userdata including Instance , Vector3 , CFrame , Udim2 , etc. Check whether your value is a userdata by running print(type(value) == \"userdata\") (e.g., Profile.Data = {LastPosition = Vector3.new(0, 0, 0)} ) - For storage, you will have to manually convert your userdata to tables, numbers and strings for storage (e.g., Profile.Data = {LastPosition = {position.X, position.Y, position.Z} } ). This is a limitation of the DataStore API which ProfileService is based on. Warning Failure to prevent these data types may result in silent data loss, silent errors, fatal errors and overall failure to save data. Profiles take over 10 seconds to load Notice Due to technical limitations, it's expected that at least 5% of the time, when the player hops servers rapidly, the profile can take up to 15 seconds to load. If implemented correctly, ProfileService will load profiles as fast as the Roblox API allows it when the player joins a server without a server hop. It's recommended to release profiles right before universe teleports to speed up session lock releasing and further preventing time penalties related to server hopping as much as possible. If your profiles load slower than 1 to 2 seconds on a constant basis, continue reading this topic. MAKE SURE YOUR ProfileService MODULE IS UP TO DATE Just to be clear, ProfileService is not a module that trades in speed for security - if implemented properly, your profiles must usually load within 1 to 2 seconds - that's how long a single DataStore UpdateAsync call will take. The problem More often than not, ProfileStore:LoadProfileAsync() is taking a clearly longer than usual amount of time to load, usually 10 seconds or much more. local start_time = tick () ProfileStore : LoadProfileAsync ( profile_key , \"ForceLoad\" ) print ( tick () - start_time ) --> A value over 10 seconds The culprit Is your code really releasing your profiles after it's done working with them? Are you releasing your profiles immediately after the player leaves the game? Functions connected to Players.PlayerRemoving can be tricky to notice errors for because, when testing alone, you will be leaving the game before the errors appear on the developer console . If a player hops to another server ( Server 2 ) before the previous one ( Server 1 ) releases (removes session-lock from) the player's Profile , Server 2 will wait until Server 1 releases the Profile . ProfileService checks the session-lock state of profiles every 10 seconds during a ProfileStore:LoadProfileAsync() call and this will immediately slow down Profile loading very noticably. This is what we would call a race condition . Mistake example #1: Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then progile : Release () -- \"progile\" IS A TYPO! end end ) This example would throw an error, though you would need to be inside the server while another player triggers the .PlayerRemoving event. Mistake example #2: Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then SaveData ( profile ) -- Are you sure this function doesn't error? profile : Release () end end ) When you're pretty sure you didn't make any typos, the next thing you should check is that nothing can error inside the function connected to .PlayerRemoving . Disclaimer: I don't advise modifying Profile.Data after the player leaves - it's a bad practice in securing your data. You should always store data in a way where unexpectedly losing access to writing to Profile.Data (e.g. server crash) would not cause massive data loss. Mistake example #3: Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then wait ( 1 ) -- Or any function with \"Wait\", \"Async\" or \"Yield\" in its name profile : Release () end end ) You should immediately release your profiles after the player leaves ( wait(1) is bad in this example), otherwise you risk creating a race condition where another server that the player joined is trying to load a Profile that hasn't been released yet. How to be sure my profiles are being released? Add a print() : Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then profile : Release () print ( player . Name .. \"'s profile has been released!\" ) end end ) If you're having long Profile loading issues, this is the first thing you should do. Check the developer console for the print and any other possible errors. When ProfileStore:LoadProfileAsync() finishes loading in... less than 2 seconds - You're good! 10 to 30 seconds - Most likely a player server hop race condition (Mistake example #3) Over 60 seconds - The previous server is not releasing the profile (Mistake examples #1 and #2) DataStore warnings caused by ProfileService \"DataStore request was added to queue. If request queue fills, further requests will be dropped. Try sending fewer requests. Key = XXXXXX\" Notice Currently such DataStore warnings may sometimes occur after calling Profile:Release() - A warning will be thrown when an auto-save occurs moments before Profile:Release() is called. It's desired that Profile:Release() saves the profile as fast as the Roblox API can allow it, so there's currently no known way to prevent this warning practically. This is not a threat to your data - read the rest of this topic to learn more. Is this really bad? If you're only getting one or two warnings every 30 seconds or less, most likely not. If you're receiving 10+ warnings like that per minute, you might be using Profile:Save() not the way it was intended to be used (See the API to learn more). Calling Profile:Save() several times in succession with periods less than 5 seconds between the calls will guarantee warnings like this. If you're getting 5+ warnings every minute (based on the nature of your game), you should consider not using Profile:Save() at all. What does this warning mean? In the particular case of ProfileService, such warnings will be thrown when two successive UpdateAsync calls happen too close to each other (around less than 5 seconds between each). As of writing this guide (July 2020), based on a DevForum thread , Rapid successive UpdateAsync calls will be throttled by the DataStoreService and added to a queue: Throttling queues Every actual budget type (GetAsync, SetIncrementAsync, GetSortedAsync, OnUpdateAsync, SetIncrementSortedAsync) has its own throttling queue. Each of these five throttling queues has a queue size of 30 throttled requests max . Throttled requests are added to the queue of the corresponding budget type that it consumes. Based on this information, and my personal testing , your data is not immediately at risk when you're only receiving 1 - 2 warnings per minute. These warnings only notify you that anything that has been requested to be saved to the DataStore will be saved after a longer delay. When will you get warnings Again, getting one or two warnings per minute is not going to negatively affect your game in any way. Here are a few scenarios where you're likely to receive a warning: Calling ProfileStore:GlobalUpdateProfileAsync() right after loading a profile on the same server or very close to it's auto-save step (every 30 seconds). :GlobalUpdateProfileAsync() works for profiles loaded on the same server, but it's intended for use with remote or not loaded profiles. Rapidly loading and releasing the same Profile . Releasing the Profile as soon as it is loaded. Can I completely get rid of all warnings while using ProfileService? No - you're going to be stuck with seeing these warnings time to time. ProfileService tries hard to prevent DataStore warnings from throwing as much as possible, but there's no practical way to completely avoid these warnings without compromising on save stability. Personally, I think Roblox should handle queue warnings in a different way since these warnings don't always signify real problems with your code. Other DataStore implementations don't suffer from such warnings because they might not be auto-saving, using session locking or try to do final saves as soon as the player leaves - features that might need to unexpectedly call DataStore methods quickly in succession.","title":"Troubleshooting"},{"location":"troubleshooting/#problems-in-roblox-studio-testing","text":"By default, data saved with ProfileService in Roblox Studio will not persist. This can be changed by enabling studio access to API services . Warning When studio access to API services is enabled, ProfileService will write to live DataStore keys of the game you're editing (unless ProfileStore.Mock is used) and you might accidentally make unwanted changes to your game's saved data. For more info, check the official documentation .","title":"Problems in Roblox studio testing"},{"location":"troubleshooting/#saving-data-which-roblox-cannot-serialize","text":"I've made the decision to opt-out Profile.Data and Profile.MetaData.MetaTags automatic checking for unserializable data types for efficiency reasons. Consequently, you must be aware of what you MUST AVOID writing inside Profile.Data or Profile.MetaData.MetaTags , directly and inside any nested tables: NaN values - you can check if a number is NaN by comparing it with itself - print(NaN == NaN) --> false (e.g., Profile.Data = {Experience = 0/0} ). NaN values are a result of division by zero and edge cases of some math operations ( math.acos(2) is -NaN ). Table keys that are neither strings nor numbers (e.g., Profile.Data[game.Workspace] = true ). Mixing string keys with number keys within the same table (e.g., Profile.Data = {Coins = 100, [5] = \"yes\"} ). Storing tables with non-sequential indexes (e.g., Profile.Data = {[1] = \"Apple\", [2] = \"Banana\", [3546] = \"Peanut\"} ). If you really have to store non-sequential numbers as indexes, you will have to turn those numbers into string indexes: Profile.Data.Friends[tostring(user_id)] = {GoodFriend = true} . Storing cyclic tables (e.g., Profile.Data = {Self = Profile.Data} ). Storing any userdata including Instance , Vector3 , CFrame , Udim2 , etc. Check whether your value is a userdata by running print(type(value) == \"userdata\") (e.g., Profile.Data = {LastPosition = Vector3.new(0, 0, 0)} ) - For storage, you will have to manually convert your userdata to tables, numbers and strings for storage (e.g., Profile.Data = {LastPosition = {position.X, position.Y, position.Z} } ). This is a limitation of the DataStore API which ProfileService is based on. Warning Failure to prevent these data types may result in silent data loss, silent errors, fatal errors and overall failure to save data.","title":"Saving data which Roblox cannot serialize"},{"location":"troubleshooting/#profiles-take-over-10-seconds-to-load","text":"Notice Due to technical limitations, it's expected that at least 5% of the time, when the player hops servers rapidly, the profile can take up to 15 seconds to load. If implemented correctly, ProfileService will load profiles as fast as the Roblox API allows it when the player joins a server without a server hop. It's recommended to release profiles right before universe teleports to speed up session lock releasing and further preventing time penalties related to server hopping as much as possible. If your profiles load slower than 1 to 2 seconds on a constant basis, continue reading this topic. MAKE SURE YOUR ProfileService MODULE IS UP TO DATE Just to be clear, ProfileService is not a module that trades in speed for security - if implemented properly, your profiles must usually load within 1 to 2 seconds - that's how long a single DataStore UpdateAsync call will take. The problem More often than not, ProfileStore:LoadProfileAsync() is taking a clearly longer than usual amount of time to load, usually 10 seconds or much more. local start_time = tick () ProfileStore : LoadProfileAsync ( profile_key , \"ForceLoad\" ) print ( tick () - start_time ) --> A value over 10 seconds The culprit Is your code really releasing your profiles after it's done working with them? Are you releasing your profiles immediately after the player leaves the game? Functions connected to Players.PlayerRemoving can be tricky to notice errors for because, when testing alone, you will be leaving the game before the errors appear on the developer console . If a player hops to another server ( Server 2 ) before the previous one ( Server 1 ) releases (removes session-lock from) the player's Profile , Server 2 will wait until Server 1 releases the Profile . ProfileService checks the session-lock state of profiles every 10 seconds during a ProfileStore:LoadProfileAsync() call and this will immediately slow down Profile loading very noticably. This is what we would call a race condition . Mistake example #1: Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then progile : Release () -- \"progile\" IS A TYPO! end end ) This example would throw an error, though you would need to be inside the server while another player triggers the .PlayerRemoving event. Mistake example #2: Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then SaveData ( profile ) -- Are you sure this function doesn't error? profile : Release () end end ) When you're pretty sure you didn't make any typos, the next thing you should check is that nothing can error inside the function connected to .PlayerRemoving . Disclaimer: I don't advise modifying Profile.Data after the player leaves - it's a bad practice in securing your data. You should always store data in a way where unexpectedly losing access to writing to Profile.Data (e.g. server crash) would not cause massive data loss. Mistake example #3: Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then wait ( 1 ) -- Or any function with \"Wait\", \"Async\" or \"Yield\" in its name profile : Release () end end ) You should immediately release your profiles after the player leaves ( wait(1) is bad in this example), otherwise you risk creating a race condition where another server that the player joined is trying to load a Profile that hasn't been released yet. How to be sure my profiles are being released? Add a print() : Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then profile : Release () print ( player . Name .. \"'s profile has been released!\" ) end end ) If you're having long Profile loading issues, this is the first thing you should do. Check the developer console for the print and any other possible errors. When ProfileStore:LoadProfileAsync() finishes loading in... less than 2 seconds - You're good! 10 to 30 seconds - Most likely a player server hop race condition (Mistake example #3) Over 60 seconds - The previous server is not releasing the profile (Mistake examples #1 and #2)","title":"Profiles take over 10 seconds to load"},{"location":"troubleshooting/#datastore-warnings-caused-by-profileservice","text":"\"DataStore request was added to queue. If request queue fills, further requests will be dropped. Try sending fewer requests. Key = XXXXXX\" Notice Currently such DataStore warnings may sometimes occur after calling Profile:Release() - A warning will be thrown when an auto-save occurs moments before Profile:Release() is called. It's desired that Profile:Release() saves the profile as fast as the Roblox API can allow it, so there's currently no known way to prevent this warning practically. This is not a threat to your data - read the rest of this topic to learn more. Is this really bad? If you're only getting one or two warnings every 30 seconds or less, most likely not. If you're receiving 10+ warnings like that per minute, you might be using Profile:Save() not the way it was intended to be used (See the API to learn more). Calling Profile:Save() several times in succession with periods less than 5 seconds between the calls will guarantee warnings like this. If you're getting 5+ warnings every minute (based on the nature of your game), you should consider not using Profile:Save() at all. What does this warning mean? In the particular case of ProfileService, such warnings will be thrown when two successive UpdateAsync calls happen too close to each other (around less than 5 seconds between each). As of writing this guide (July 2020), based on a DevForum thread , Rapid successive UpdateAsync calls will be throttled by the DataStoreService and added to a queue: Throttling queues Every actual budget type (GetAsync, SetIncrementAsync, GetSortedAsync, OnUpdateAsync, SetIncrementSortedAsync) has its own throttling queue. Each of these five throttling queues has a queue size of 30 throttled requests max . Throttled requests are added to the queue of the corresponding budget type that it consumes. Based on this information, and my personal testing , your data is not immediately at risk when you're only receiving 1 - 2 warnings per minute. These warnings only notify you that anything that has been requested to be saved to the DataStore will be saved after a longer delay. When will you get warnings Again, getting one or two warnings per minute is not going to negatively affect your game in any way. Here are a few scenarios where you're likely to receive a warning: Calling ProfileStore:GlobalUpdateProfileAsync() right after loading a profile on the same server or very close to it's auto-save step (every 30 seconds). :GlobalUpdateProfileAsync() works for profiles loaded on the same server, but it's intended for use with remote or not loaded profiles. Rapidly loading and releasing the same Profile . Releasing the Profile as soon as it is loaded. Can I completely get rid of all warnings while using ProfileService? No - you're going to be stuck with seeing these warnings time to time. ProfileService tries hard to prevent DataStore warnings from throwing as much as possible, but there's no practical way to completely avoid these warnings without compromising on save stability. Personally, I think Roblox should handle queue warnings in a different way since these warnings don't always signify real problems with your code. Other DataStore implementations don't suffer from such warnings because they might not be auto-saving, using session locking or try to do final saves as soon as the player leaves - features that might need to unexpectedly call DataStore methods quickly in succession.","title":"DataStore warnings caused by ProfileService"},{"location":"tutorial/basic_usage/","text":"Most of the work with ProfileService is setting up your data loading code. Afterwards, data is read and written directly to the Profile.Data table without the nescessety to use any ProfileService method calls - you set up your own read / write functions, wrappers, classes with profiles as components, etc! The code below is a basic profile loader implementation for ProfileService: Note Unlike most custom DataStore modules where you would listen for Players.PlayerRemoving to clean up, ProfileService may release (destroy) the profile before the player leaves the server - this has to be handled by using Profile:ListenToRelease(listener_function) - any amount of functions can be added! -- ProfileTemplate table is what empty profiles will default to. -- Updating the template will not include missing template values -- in existing player profiles! local ProfileTemplate = { Cash = 0 , Items = {}, LogInTimes = 0 , } ----- Loaded Modules ----- local ProfileService = require ( game . ServerScriptService . ProfileService ) ----- Private Variables ----- local Players = game : GetService ( \"Players\" ) local GameProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , ProfileTemplate ) local Profiles = {} -- [player] = profile ----- Private Functions ----- local function GiveCash ( profile , amount ) -- If \"Cash\" was not defined in the ProfileTemplate at game launch, -- you will have to perform the following: if profile . Data . Cash == nil then profile . Data . Cash = 0 end -- Increment the \"Cash\" value: profile . Data . Cash = profile . Data . Cash + amount end local function DoSomethingWithALoadedProfile ( player , profile ) profile . Data . LogInTimes = profile . Data . LogInTimes + 1 print ( player . Name .. \" has logged in \" .. tostring ( profile . Data . LogInTimes ) .. \" time\" .. (( profile . Data . LogInTimes > 1 ) and \"s\" or \"\" )) GiveCash ( profile , 100 ) print ( player . Name .. \" owns \" .. tostring ( profile . Data . Cash ) .. \" now!\" ) end local function PlayerAdded ( player ) local profile = GameProfileStore : LoadProfileAsync ( \"Player_\" .. player . UserId , \"ForceLoad\" ) if profile ~= nil then profile : ListenToRelease ( function () Profiles [ player ] = nil -- The profile could've been loaded on another Roblox server: player : Kick () end ) if player : IsDescendantOf ( Players ) == true then Profiles [ player ] = profile -- A profile has been successfully loaded: DoSomethingWithALoadedProfile ( player , profile ) else -- Player left before the profile loaded: profile : Release () end else -- The profile couldn't be loaded possibly due to other -- Roblox servers trying to load this profile at the same time: player : Kick () end end ----- Initialize ----- -- In case Players have joined the server earlier than this script ran: for _ , player in ipairs ( Players : GetPlayers ()) do coroutine.wrap ( PlayerAdded )( player ) end ----- Connections ----- Players . PlayerAdded : Connect ( PlayerAdded ) Players . PlayerRemoving : Connect ( function ( player ) local profile = Profiles [ player ] if profile ~= nil then profile : Release () end end )","title":"Basic Usage"},{"location":"tutorial/settingup/","text":"ProfileService is supposed to be a ModuleScript which you can place inside your Roblox game's ServerScriptService or wherever else is preferred. ProfileService can only be used server-side Option #1: Get ProfileService from the Roblox library Get the library model here Move \"ProfileService\" ModuleScript to ServerScriptService: Option #2: Github ProfileService repository","title":"Setting up"},{"location":"tutorial/settingup/#option-1-get-profileservice-from-the-roblox-library","text":"Get the library model here Move \"ProfileService\" ModuleScript to ServerScriptService:","title":"Option #1: Get ProfileService from the Roblox library"},{"location":"tutorial/settingup/#option-2-github","text":"ProfileService repository","title":"Option #2: Github"}]}